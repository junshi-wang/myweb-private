<!-- See https://github.com/robinmoisson/staticrypt/blob/main/lib/password_template.html -->
<!DOCTYPE html>
<html class="staticrypt-html">
  <head>
    <meta charset="utf-8" />
    <title>Login</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
    <meta http-equiv="pragma" content="no-cache" />
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/github-fork-ribbon-css/0.2.3/gh-fork-ribbon.min.css"
    />

    <style>
      .github-fork-ribbon:before {
        background-color: #333;
      }
    </style>

    <style>
      .staticrypt-hr {
        margin-top: 20px;
        margin-bottom: 20px;
        border: 0;
        border-top: 1px solid #eee;
      }

      .staticrypt-page {
        width: 360px;
        padding: 8% 0 0;
        margin: auto;
        box-sizing: border-box;
      }

      .staticrypt-form {
        position: relative;
        z-index: 1;
        background: #ffffff;
        max-width: 360px;
        margin: 0 auto 100px;
        padding: 45px;
        text-align: center;
        box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2),
          0 5px 5px 0 rgba(0, 0, 0, 0.24);
      }

      .staticrypt-form input[type="password"] {
        outline: 0;
        background: #f2f2f2;
        width: 100%;
        border: 0;
        margin: 0 0 15px;
        padding: 15px;
        box-sizing: border-box;
        font-size: 14px;
      }

      .staticrypt-form .staticrypt-decrypt-button {
        text-transform: uppercase;
        outline: 0;
        background: #113e9f;
        width: 100%;
        border: 0;
        padding: 15px;
        color: #ffffff;
        font-size: 14px;
        cursor: pointer;
      }

      .staticrypt-form .staticrypt-decrypt-button:hover,
      .staticrypt-form .staticrypt-decrypt-button:active,
      .staticrypt-form .staticrypt-decrypt-button:focus {
        background: #113e9f;
        filter: brightness(92%);
      }

      .staticrypt-html {
        height: 100%;
      }

      .staticrypt-body {
        height: 100%;
        margin: 0;
      }

      .staticrypt-content {
        height: 100%;
        margin-bottom: 1em;
        background: #e4e4e4;
        font-family: "Arial", sans-serif;
        -webkit-font-smoothing: antialiased;
        -moz-osx-font-smoothing: grayscale;
      }

      .staticrypt-instructions {
        margin-top: -1em;
        margin-bottom: 1em;
      }

      .staticrypt-footer {
        position: fixed;
        height: 20px;
        font-size: 16px;
        padding: 2px;
        bottom: 0;
        left: 0;
        right: 0;
        margin-bottom: 0;
      }

      .staticrypt-footer p {
        margin: 2px;
        text-align: center;
        float: right;
      }

      .staticrypt-footer a {
        text-decoration: none;
      }

      .staticrypt-title {
        font-size: 1.5em;
      }

      label.staticrypt-remember {
        display: flex;
        align-items: center;
        margin-bottom: 1em;
      }

      .staticrypt-remember input[type="checkbox"] {
        transform: scale(1.5);
        margin-right: 1em;
      }

      .hidden {
        display: none !important;
      }

      .staticrypt-spinner-container {
        height: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .staticrypt-spinner {
        display: inline-block;
        width: 2rem;
        height: 2rem;
        vertical-align: text-bottom;
        border: 0.25em solid gray;
        border-right-color: transparent;
        border-radius: 50%;
        -webkit-animation: spinner-border 0.75s linear infinite;
        animation: spinner-border 0.75s linear infinite;
        animation-duration: 0.75s;
        animation-timing-function: linear;
        animation-delay: 0s;
        animation-iteration-count: infinite;
        animation-direction: normal;
        animation-fill-mode: none;
        animation-play-state: running;
        animation-name: spinner-border;
      }

      @keyframes spinner-border {
        100% {
          transform: rotate(360deg);
        }
      }
    </style>
  </head>

  <body class="staticrypt-body">
    <a
      class="github-fork-ribbon"
      href="https://github.com/a-nau/password-protected-website-template"
      data-ribbon="Template on GitHub"
      title="Template on GitHub"
    >
      Template on GitHub
    </a>
    <div id="staticrypt_loading" class="staticrypt-spinner-container">
      <div class="staticrypt-spinner"></div>
    </div>

    <div id="staticrypt_content" class="staticrypt-content hidden">
      <div class="staticrypt-page">
        <div class="staticrypt-form">
          <div class="staticrypt-instructions">
            <p class="staticrypt-title">Login</p>
            <p>Member-only contents. Please use the password to enter.</p>
          </div>

          <hr class="staticrypt-hr" />

          <form id="staticrypt-form" action="#" method="post">
            <input
              id="staticrypt-password"
              type="password"
              name="password"
              placeholder="Password"
              autofocus
            />

            <label
              id="staticrypt-remember-label"
              class="staticrypt-remember hidden"
            >
              <input id="staticrypt-remember" type="checkbox" name="remember" />
              Remember me
            </label>

            <input
              type="submit"
              class="staticrypt-decrypt-button"
              value="Open Page"
            />
          </form>
        </div>
      </div>
    </div>

    <footer class="staticrypt-footer">
      <p class="pull-right">
        Created with
        <a href="https://github.com/a-nau/password-protected-website-template"
          >PPW Template</a
        >
        and <a href="https://robinmoisson.github.io/staticrypt">StatiCrypt</a>.
      </p>
    </footer>

    <script>
      // these variables will be filled when generating the file - the template format is 'variable_name'
      const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
      const templateError = "Bad password!",
        isRememberEnabled = true,
        staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"8730671f5e5c08f705c3b1a0a31cb8e58640ab91406fa349f4ca4fe651f6f18bae99549df470b83a8fd8fb0ed63ae40de9c0f4791c960393fd0de8d819dbd5c82f2a00b51913a53fdee01f9de138e2169157ed22053b4b32ad06cfbf8e55a7b06588ef6a1ecfe3c58a2c8a83af40855d3150c2b4da4ce40acc84a5478c090719599024b3105fc86de02b607ff0aee62267cba19a5477da2575307dd3ee7f7d52877ffea01e469f0acadc71dc9cf7c6d8c811603ce56a3b8125d181a8564d9a0b3f808277f211169108a989586783853f55a0b0337a3225e9976fe8efe544e08c0f034668358adc5c50087104d5c9879a5bc2906f2c9d5128d42895bb35d4d0034a71569493dcf5c9ee0a279a7b16884bc73854400cf42e2e9540c9344bbf0c7b27b0d6d79462a2227303915fd087a976d72224357a1efb27371e1eb7595cda221a6ca8479b60b4bf9808ba7640e84ae0ff80327ae7ee87f7b062d053c1acf828af6924671e497ecdc047cd79dddefc154ea831cab2bd69c4491c2c1d56096aea58f1a84f6088795266b2866e23964d36e2576c3e58b8c159ccaafc1a665d75c82e3e6110d98ff241b915895658af284badd8d6088d5d1939cf0e749ca6fe60a0ba7ed646bb3eae712911e375ede271966b4eb928800733acea533c523229a4f1d797c43597e1cc7e50807a263d9375fd6d7b46e01b42c74867d308b7b3ae6c1516343d0bbfccd665538f0718250e3ee86d257e7fa855a1f597d872cbacacaf521a6197e3cdd153a7f50251d5982ada9325c419d5bb91b65133c53a3c7482d6f5d39b8df01be1e7c38db960ec3902e12810a4007e04255a87d6d9ee9bdd70aeffa3df140adccb1bd925e46697144274f1a0ecbd5cd706050585e22daed2d24b7c820268669649a03180aada072f70cb27b2916f342db1c3e1f6dfa3fa3b130a6e30440e3aa4b40763cae4b711f388a8fab1a71dbae64a80b9ca004a77c2295588b38eef104188d3b0821d13df025d3e1774693b1888ef44e9200f8d9c27aefc27a7756edf41d6e4071ca25096a6e74658f89547039ba1b601b0510dffee93199f96674ceaee416f4240bbaa16d58efd91d26eaa1906d7256936e82f504da0ec123eb4d35b6baf41aa330ce0ed21d62d2f2305dfbb408dc913e2cd9597183804594bff7ac0a1d27738bee99453db0993632fdaf6bdba5eb6abdc94eed90ececc18f4c5c2f65d46bf51117f58c6ad61641cf1556ca0d2a860bdd19d95e83e43b7b71223b84a67cc5b93c74c8c50cc9da5f2a992e9983fad50b0c6182fea89ddfb801a80c555a31f0b2e2ec4e5aab3c3a4ffc4c5106ca24e149cf3f1c65c406f900d2a11f4340fe031150a680497115e9e34ab3a2ffdd791ad6a12876b951a99e69ad54bc696b111941f5d2754601521c1c82d27b352db620fffa040026c3efea75a89a6a1b884b725e7ec27fe4d396155d01e601c90fd159c8f47950e71da6ff46b27c2d3dadc8f01166c56cb0d866a9eb290b8263a9af96bbabf49c5301421f42fb23f63c15f48fcd8f870c9183edafad994f1e4dda8537a66a9c095b735bd5476930b3ef258bf07b8f4573a86085b23cdb0676fe6515efb8b964c79f11e37db75fab543ac4c5c27f85e8e678e389114d73889d503a4012fc13b0bdd1e5977b6e6fe2ba48e6c0fef54c612e161886bb81f9d4282dbac60a5fd6448216f271f1cb24e8e13c9b1cd87a9bb0c3ccb494ecf22fe94771db70d4df34c8d3f05191ad1e70a24c74b2bd4ac14882832d7d725e316cf355899c9ac02622c7784e1d7d8587885c6aeffdd16e423861b8ec9a9a8657d4c0a2902d13a6b18b11d3fbd6e3f924846606950a9ee6277d274e6f1ec761f44e38cf6e1dc0f33fbeb6ba9754d41d8a2d8b41f3e3c74e016e9f8b0147ab7cb3a7a3addc98e3e9450bddae27ab3b6200736a5db13645794ad4de3a89fe7faadeafeb950a1816a25b36c40e88601e29beb4ee0d77b7b7769a90c95b19bf812188a8e4a2f85b1531fa3a15e190738065cd68e5921627786eadca9d383708c8770f016ce670050c4a0befa654df73afa5697cd4c84c31d24b9b9366058ee67298f5dd4df74613c6a995feb6ab8f1bf774b426c71561426635dcb59bd8cf5aabff7598177334076ee480d97aefab2ad7d742d49fcff3235f5ed738a8e8ba5f29b174d659e334ae2c393ee2542bf45211bf18d45c01f84fb1202ce3529a2519e5e40f9a4db9297e1c8a75f0b03ea533437077401ba18d8fb230605d2a99998ce3aff29f7ef5c47a249bca8be501f5f573d70014b28be5e7bdbbc9b5070b9a42af7eb0126c65811ff1de1b545d2f2ea776d517c5b5191b0e3aec0da613d4a67336c01f51cd8280f647b5abb7e7420e617f6c35ff3b864d1887e7f7281ef1e1c7a6b5cb96a681d1c649f73338e5241b00992daa79e355e646a729b69caf0e01e1caa1b2922e34e21ecd978bade6f964ecb22a0f93d09e8607c2b67b1a9311bf443984f34867be1ded9d46d0b04f13ba9e84890c21fd8ea3064c05a77e8ba28f25881147fd7bdfe869df42aff52cf4d2560e1c6d64ab3101ac0daf4a523b8b8a5e1f7426c04e8ffeff0d20b5150933aea5e1651861bd67068af538d201e35fef6fb70d4230dff975ff97a31862d4fcf50f3e64f59b14b40943cb911418b31c3170897acd18e1a484ce4e50504dcb60dfb5aa0d44dc4d726a8e96308b04d5c5447bf5d87e57d97cbde2a633b3cbb56efdc1317d6111bf9ba2cad45faa1936b6c0a54c55718d2c882014e4abd15388cba22959d432bba26bf15728fa85beb9dc33018a508228abce7ae0d84f2f96d86771ea3117b8f90e1e612746578f924e411d1f01d4d772b05cb858ed5f364e16f6fabae562002e05d9640871cefe2bd14b9d8ab4e19e68a063b18213eaa2c245168f310d02efdbcd20d41130515481224c91c7fad2647ce6ba75ed268407da24b404188a8b4af2dff096e30195586d423f08f4d1c17defece667eac6733d678e28bc19cfe28b048c91bf25747d6de72c0aa1c9d62357b9a4cf528e3427745fd348631d096e60ea314c063b65da4b4cbe25d23f49529735c0e09ecd68a5dffe04abde360a8e127829db44c1ef187046ed18057688b88bd705089857fcc1e02404d3b2f49a174d46991487fa2a8d446a02e82c9650c47df4c6091855f48900d2207061fa618949301ee279143b3dba03590386d28fe4aa5052af3bc7a1476fc13138a0dead94b9520f263464d1a1c5b40a68fc128e0d53978c42a8ca406346bfb88cfd211b606202002ec4d2f6ee9fcda820417cf5cb5ae7ea9c378a63e366be902e6259af59f7c03f4b7c09bdfc4c7fe93ec2560eed3bbf53ad5b8ad16cdbecc5aa449e32024b83b07b2bd0faa6cf33e2f583cc6fe3bf7196194bf707bb1c20e269d93a6464c47ce6ac5bc161688e7258d29877b5f108ff9c18da9dc5672472659c0e9191509ac8389043e7d6aefeedb730684183c8474c06737154cfa5e17f6a0dd3359b6a1630b6d10426ce06a8f7a98156bcb60d6341cca5bf7efa8015cb94a2a3dc0e89e6e08975dd6d43b6a1b9be22b3d574cdbcfe3dd34ada08189dbee208d624eb071647c0c070c1c9459a7cdd29257433cb225b238875d0eeb1371dd47bf8f70d74cc74675f3725ea65f648d1613efa6bcd27a1ba43183b9293a761fc5fbcdc132f4729342ce223d3a0ed8b4cb694f14767968299b9663a3321824994dc19bfa7bafafdc870ce916ffc7a5a44c99e1cc0982a14e57616ed15b3ea360a9fea2a5043a39f838136744768c799e238fb7686509819d45ce6f945ef53b23f24b512dc943f2ef8d7398c167ad9221d9280f06fdde52ea94c7f6c9e06469c1dd80dfc608844a6747e47ada9ccc70c8722ba289a3470b091f115d480a7dabce9f622143a9c9c2f82ec555f49a5d47f1efd14738a950d2555fdad699a78625783cafcaee9803d82dd648bc1a3cb281ed6a6f46da203847ca7f7202d4b407ec4b8def071c81b6b6d86d530b705fb5c552af664297933dbf37ebf4d40005c8b7958b1906fe6ce46febcd403411cded624c24bbedc065ee2a283f15124a41924700e1e2ae410b48facc78e32a68ad88581f0aa56a6f644f7958c28aba370e4bcba18a883af551b39f4214688940a0cbc89d0996af7358e871f63d2ad9066566b6de05d237828da4b2438744f01f1560b436a77a96d95abb86d7c175e48fa36f0de1ca31c680fb4af3f18268948240bc98a73337da383401a3ed74f7c8c3561a1387f0bd30b8acb85c3aa774afd1f0a7f9161a6c90cb28483dbc41a47d5c9216ab9df07fed89ce471599558cfbf3013e60454e6942fcca26233c778cac7a0f0200c3720c6b120a6ca2a310aebe744a5498ae2e78824e7223cb71d9335171d0680db32e2bcd21d1e5acc261882772b0cce01640ef3b00808202da2befc95adc276e446ed95fd78c879ec6130320a6b609137f6e5e0378e82ca2ee547a9d3e0e8fda89fd4c8a5d166736866725708db12b6e1819c11c9204b8368c06ad3ca5f399c6849da8ae61daf556a78eed70e14b9f036e9d48345d4f6c01ac96dec8cee4ca459b27977992ab3b8209cb4a01ab258d326162b06301fca51a18af9088e7c248942790d75321cd3e3a1db96d3c7e2b39eb81b5941151274e7f34682c3172aa35a349f8408f301c5931afa5e8dcf202ee222136c176ed6e44d4d87f661c9b95b1889cea2d396c570d7d62748551843f5b961ce7244573d7ea1374aaf352147015f2b6a60931ff7233409b5045629054371522303017f16591d15cbf2ca4eb0aa936bcf9e5f1e29d4005fdad8009eed40aef8f860656862c6852f35f5af849514ea6d4a1bc7540a69ca9335953ad103363c0e87b5a1b8ad1ccad25e7e85313a0deb6a0f92ba99c30a5470d4c9528661ed64bad90b206c3f67ea0d5360e71f0983923dc78741e817d764f633ebf1e4e1e17dea33880455d0e36b0a3e26813702d5f052ade9237438f787016ec3d700124ada7d4655f290278c9cd762216fc9b5a02573ffac48422e226d9721fbb2086e3037007919c13f31417014caac3e63686c11ce540d72bdfce562a43e16de29f77c567d0175bb26ae407500096fc86b93921f8f6bc86ab9c1206eb5aa093ce358c128a89237d9561b124bc2a519f1a34f9daa798ae048b895558f6d43298dd1d58f3d8b29b9bef54ff523ff39d446bb66aaeac08dd8c5d91555bb721601b845a50433e70797632f9050abc9f992a0081f69ec5bca2962a10ea9f0da4db1f752df8b8082437264f0a4da81748ae22564053c3bce892039c61f2016cc3e6829f01d33921d2bfa73cebaa5d09af4703731b5d2e67a64936fc4b6cd4ce2f780b3a754dface975f275ca3cc39cb8eb53fd9669eefb4d57513834a9d1dfaff6f324dbc24b174e50362995a22b8d47a25499e8346fb40f99c0e6c65b561c10d02f4368af6db55713e1558b0db92063baacf035b9ea07cff15107a8b6e4975a6257e819b81b7a62dc5877c77207ea4eef9d6fdea7d9d9df81609f3f2f25c6036d1da245931b0b069676ea2e0ed6c302332e0fe1c040ddc0e17f5a956a9939a700821c6d3c044262d740322a059adb8092907a920129c01ebc81d55f9db5553145d4e805088363df0d46629736fded022cc6c74ffd1b18b15d992dc64649750bb7e865fa70618f15c8505aee2891b8941a9073a4304fdcd46386fd9fc3d233c7e20840b7536b3c528c61ed16bd1b7503791e4be2e23c7728d08d75d600033f172a65609b19d76d2df46e267c1e8767140fabce40425645c887dbf5e6eaa7d7085c8e78379543b008541efa08e6824c9e5d3507d91efa1388cd8472c6f5854bcc0ff30a75cc62fcd25ed1434c098dc899a37bb2c735cf636b9c15242e38d75c148d3cc76b833efc4d22cf90efc8037376f9bcd7fee39dfde07187e374997d1d645866b261fba38ffc7f3611361898b66a4e929fcaea7094b0c4c75faeca3913a2b9f5f681a4de5c15d8dd15526469e7ce92ba357e4f6c7ee378978982b19a9de8d6eb3286489c977892cb35957f39e1f0857f0133d6621c7410e6fc8758949b38848b21e9806e59e9e02816b022ca162f28437da3127d2fc95378ebfba20911b765da43dcb564453533f4da36992305b6ebc6e814ca3474d679913f7a0e880d47ae720912e0d528165d5734f07b23b39258e6f330980121a239893deb1ad9c917cc405a6bfc87035fb8f25fb59b9fa68344869dcf9bb5f9317512986f57d0e8ef9f588f5748f3470caf28df31a2bab8effa3d5749ab977727b4bf79c7094057379254661ff780f63cce9d5073606f70bb9b28ca492cd27c0fc3dddbf2c7bf714800b87bf9d8379d73126c88787c49ab79cb6bbef368b30746b4f1ce162d8534104c04ba916e1c8571ff83d0ef0a313ca4cc8705f9903f8930e4539b200c55694af0507fefd1a941c9d4c20aede094ba4408c65597d47ad41850ea0bb18bc82a70d4bdbba7067d9b321fb9fc182cd85c19b988e297d4cf3a7d0c9bb1afa30d4acec755549df957bbbfd6ba47c7d67bd0c51ed7addf5c222f96c655eaf2ac84a153cfbc8494ee0e93498cafa8308032c557235f77245e823ab0e9b489a6f6c09554c65b6ca4942670284715f658303438e02cb02b91c3514cdcd92ba7c8b97e96e6efffdd5d076f91c37ebabb608fdcf3377146117370450fb10a2f43ed933b06f8b1192a168f66083293fbe8971e83bba24c5a077dabf0bab6c4975a893ee04b8a7a2dde27c28c646cb588cd282527dc1cc21d1f262881bef0cae91775c75ec25b13f1d5d3ef767e1d6634653b4d8428e4ab81d185716ef039dee6c2df810707da7cc59718ff64bd2ea8a1102e6c6fef55dfd3e5d8745f9bc05d363de4a4f51c4e5fba94b2e62f528950a16f16ee379ce9ac7f4e8cddba9f7b2b58007883a9a5172ad6d30e8d094fe8693a445e96cc39723fb34f5f511dd9b59fd220abc6f58bb86b743c9568c40198386ad5c8f27c73bac3a490f3e9d3fab7afa6d721b765a1481939e62e7dcd69dbeb339f63551b17e8a95aad3e017d9dd4652fe86d389125cac14c88184c0ff957fcf15e01dda7cbd752f5302059d22d4aaeed6489e65b1500e7d6bf3646828680f28c269ed427f319671c204de17919eebadfbc015b364bae096d1c527eb954569e34c6d9f0c4526a51f5a87a97167389be5f03aeefcbab7df98b1eb5273fb4925be74ba3ea5f652ef7e9989c1a0b77250e1b411e15887e212e9743da16fa7a66b03aa2fd41f0b2d97c3ddeb7e82646384a0a7d5333779e6bd2ceb002f0f14e6d6171e5b4fc16eb1b829132369ac5ef36921c251908d803ee79619e5a9940d36e6fb849000b17fcf17e3739ebbcbb5eda9c102085b74e4ea626711521017a5e86a5b8ef778cb99dbbd250a455bc2f7b8a92f09c94e5b60a92db1db2380cd7e99e68dfccf77e853de9e70f52ea29d2e78cac99a2338cbb484e1be6844bc7c9661f07d11dd16a7ed297781aea571d19ba5b7e9d88c08f420a427da4d560729fbedea98e6dd928a737cbf60eac974fdef87d5f3f9a5cc9d4455f0d6c61c2a5030a7189b4ce4f36ab7394ea555d260d354bcd48c6289442e228817131f2b23b51ae9f1dbfbb7b27829976e0c17e5074629d2111c3ebf722578097ef717e04d062c1758f6b17a295b2a0c1935dc0bde3aa1820ca69c41b535c8f6e81cb866ad4cd55c4949ca06a77fe5d1e80b96a599485dd92c1ca72e4456adc61d7b8539f9ed0412dbb164da2eb053ab474adf665a433050a43872a38a45c586776718387425aef5762be784681bf494ce2f78a5642ff05cd23da627f005e45f79e69f32cbb88256fdb6175cbbbc91344f3918fdb929ded734a0226b0dfca23ab2260d8a165b670ef2c73d9b3c322e0c8f520b38f990d11baccb39f3b26c653da28e4ab56563d5d77b9216945ff703e1a8471b13ecc0dac3d776c8cf371e8b17b6877fec46808369aa508e1b629bdd30599a115bf836e631ee411f7bf5f74d603c5246845c8df59ab25b12a8b2748dae00ba80255a788346cd913717bd6ee06772ba723d5a992903bf5f94273c22c0622f6b3a1c00e44a08b94aed060833f54f11abd08cb3526d7097cdae71b6c8c0fa45081c5d8a0efcef99a54e86c115954f004fbaa29c20d247fb4e2081b49d42abf3135f72ed1ec0592abd05fa7ad24d6c22e2b202bab8098ce0a411dd937f63950dbad8eeeb0d419e64e9d19c1405f4a62410676e3f46c45b52c334a2c94ea3dfc530ae7d196b318a623b5710529a2609af58ab516e4adf793ab73b64a6adb02e8491a122015d7d15daa37f147bdad77c033d4b92a76ae0759f910511782f84f5c91a8d5933c53c4d44ec970f7fd80463bad029c3a4f6ec7c34d1090d7679452dd9a3bd2dcfc00bc1152ea9c0bf91b55254cf325d7083cbfe3bf7217bb2485cc1b62cf8788ccd6b570b87e7f33f44acc9335f6f0707e8ccd2b314374365192242996285d28c0cd309edf7646a43352fc3b2a379b64321a4792d71874da2cdc08be0c9c4bf3ed930fa64ce7fd63dcd20fc36f2865925e97c88188553b7be5eb9ec37c57beb8735ff05b693e5b30c073d9bf77b28fa06a27afa2102fee5c41e90aab3f0f8f3a80fae64ca4a03ac151a296bb3bbad974ae4b64c46b0abf4e49a4d91cfafbc4f12948e66fdc180ad26ce6c12da7505ac763e78cb620c5498efc189d6f01bd0e5de6410eb8bb6071fe73970b063fbf89adc3be02887abc7fa6df98417fd5f4181ff209ac65e5bf3140282fccd921810b2566c43e3ba768294c6f62dbecb79e9940d60a9f9ef5925dfbfeda71ad709639ff817145eadc0e89f794f3f6a03be9548ce7d4ebf9b8b07bed2cf167ae49dfc9d2efde1c85e59e3968d57ffeac677ae5324b0033f4bde3d9a1c8c5e47d4375cf4228715cb0792a7ab50961b35f07e6370bf94c067f85c550c8d0a9c945341fd3e1ba82850d6801e5107b099bd6f2e8d0a3b0b4eb8f41135f7bddcd83eee3f3e324c5a0fdd626c8572ac67764a775abaf719af54d6850bac405f055885ee759b0340b7fc14cc31ff0e37d577b59dc7e35c023dcc2cadb2b7274fce4bd9bfc6378cc858e099220b444c44b20784d0faabb40ddabb0103de825e18f6c7a31dd97214402cb400c1ae7f05a545400e190055084329eafc4af2d4bcd26dc473080bcae67b38114c30ac9fb649096fd2708c73a069798b35df63bf5080f49f12ff5659e381498d158caccf5191cb568a8de5473a4fd58061a9dfcc037aad90756635e4932f6c78f2ee27d1e1b39a68fd92da20afbbc36ddb7ba292e86d0d20eac91a312414f5b0bb90bf8b38f683889b90af5bd9a873aa7804ba0d6821984121bf33b52052a4adaf3575850ef2e03aef6c49e7ea1ab5d8050b1933f66d5311715ce431e28ff6b87960085860b72cd3067a27bd697b4a8e8b336e0c027e9da7bea94d8c5bd08e19a5719a6b34eb17b48769003923e507d03d1a8a9986a0f1f4b0be64216d43d5b9a360bbd14ea210e56b5475f943c6cded9c76eea9fc322f9d7cf93c88d66e52d1d9c208a3215aa64d8192979b061387402487e79f4cde96c43427919756c5b7f8f22f22cd2396d70261d07040f3e1e151c86fd58498629b193b980b7982ccffbc02efb889c31bdd7c6cb684e7954406ee6c4068ce7d989795d7178757de11d4224ec67abe046bc42c191ccca1b9f0e73de843798a8c9686dbc887074d6f731d02599b37feead2549981c291cfbb4200a8a9f9a58645a951b420bbcee28c4f1375670bc1ddd06cce8ea58e81c7c52dd387748626e87f0b251e96822902b203e0b82b6d5187157236007d6b92f66e6378ffdb6f093f8ccc41e5069eaed803f76e0db24b38d2ad33b9868a48d0a1597ca0501037602986ea95d1bf00ed73faa4a0b4296f30e7610e011ed23582a68232df1f0462ccf1c8f3e199111cbaafd72ca9746a6a7b663e6236501beea80eeeaddba6001dbb42e066182f3a2eff1aa442d1c2c3e831d7a9f8f7918c9b7719fc3142e4710d875ef3cefcad32cea90fbe5795124914b578a0a855a1e66af0ac6f55b117951c33bb29a5790ddadf1bba917c766bd492343303b1f9b37331040f614e9b7f5bca6fa9347e7e48a534c40434b5a535f4c8b85322d856c95f1abc1d58fbf92470a4a60b8e2709010ca0e54cb8b03cd0916cb8783a408b4e67b81205161ad79b1c0e704dce785311a5ef59865c0efbef4f899390b2a072018338c5c2513cb1edddac257c57949fac74908e6aa295551c32e9c8d0a44f866b38f1002af2398ec8f82f40cbc0746377ae7484444658793975a20d10af0c9085f019a6020524c5341b21c0130a621fd6c41f32cb7864ab5d5689b643aec3ee77a3d735182d04059bfa447c9dbb7202777704d53daef714c55af24444704aad3ddfadb2d739419da0eac5bf7e4f3d68b2e679e0b349ec55263c0ed33dcfbc543813472c332f2e0fb5333a9ba7f00435124abc8d807f201583fa118c1a61db3fb39daa834686c4e059a1ae5a09fb088a1baccdeefef9929741d0d4c60aaa83939c6c8943bd02cdfaeb848ce34145bd62c9c4797aae291b0ed4785441c42c5c91a92d14cd700522ac90f033dcad9454c7bddd0019ee5e57f194542fd779728e5a295f90cd619f5b9ea223095b26768d24bf6d91efc816f0b4e43d303e29d30496ec51beb75e1fc9616077147cce0f7123095ee37a01394ab68a41519ca50d86f1832149d1b475a632636b57066b626da672e5c912c6f7e8a91b23848efb0b72efbf5dac74543d36b3c0b1c6ff4529cc732280ccee3e32bf68c1ad67a65bcdde444e795743ef932071985a256e516d6d37a2790329a2c91f3276692a0fae27278a7dc74d1aadd44d417856c3a21b53a6cf4dce275dd5b60267f2062b2b3bcb30218172e325f0d794698e6aa40bb96ab0cb89b04dc35e61a414cce33c8d9c6b0b7713a0e4acad4ee6e030ae3bce8769092cd63ed5bdfffcc4b77ee0d1982e16e82d0695817d45994589177f857fc93c23ecde73ac8f52d62eb2c068318c5b9999a9a66ee8248b1d442fc0ce277ca2d5251a4dad1b52c370b71c41a5ec9ff09553ce42acef13828a807e3548c4ffb745427ccc324d93edb453991b5fe6e0ca17a1376d62fe48566c4edc34aa9c5083175f6b94e35c9480fa9edaa35be53c08516453c460abddc03fe0fa3895eb59ff1c22625405b1b1c10ad035daa7d91efc1e4b3e3fd28379a854d82a92339606b3ba657621e51ca83c7b51485c79e39bf3b9fa10ec19bb02e1a920ea6437522d29246b5cab7e981f1e3e99d71a5fa99ac4797ed1c93b6f700737dc8be38512e32ce66173a457e5d965398f450f6b65a6cf2d1553f42fe71979ea726c27328ced82c875a93f1d266f47cbbb97a1b8f34a9a4fcb5414af88e8778ddc62eb844ec0246193e5bc9b0b4ea8f714834cd9004ea8d8421cd88e248828544a1580ce6d256f8c5d9924254bd919d8df911d079002431c06a4e9154a9d0f6bd01c7e45566ef501c2477a4429605c1e3f4a86e4dade351bd5eed57565cfcf5a23e5bd4f890c05af034772a345303f72719c820f1b45b72427559be108b6d72f30400c6f2abc69ce117d183b4bcdd2d9a5b46cc07c4670ee406e3bd8cdb8c1fa102e36f57cb804c1386650fad952fdbcbf74ed205e33ed8a26a8c85ded0d817f3b2b58d4a436d5b709e350d73f6f3bd4aba9dc356dc2bbcbdedd297fbf465c38c38594c034f916c79eb3bc7a0a91a438d707290e26144d5d694b8fe0dbfb0297028c56b60a52902f0c032a37c8c4b9a76678c3128de668e2b46de044433aec93dd52a517823db1a1fda0b6b39e592d43835906c407da37d295735a08e32458f897bb475ab2af5e4dc1f9fb7c34519fca03aa8430fe39a494e329e6f7cf2314a7836537943a61613bda8e1d21ded09296c2f2c93c3350ae60a002b2bd59fe8aa8eac0e646dbb59ba870d2a4fc9796fed4c8315115a394af9c6da7a478b586034699fcc3d3c2147246015ac5230973ae8d103452a7851c1af354b58287c680b1f6dfd8131e005fcdc7169433a48f89e9c80bbe7666f65a9eeb5932d708b6d171173a6dcdfed8ecff9f54e8c853408f0cb21be817d5981752eeb4500728361029ab675a006c26be46cee4c16ba032418642099020d96da1b0c144672d9112c14c28433eb2560affe5ebb2f9616c79b83e10444e2dcb87ab6e5243e3767b9dcdb16d5394d81095f4645d7a05667cc0066b231c0abb49b5c5e097ff5bd9799dfedb334ed321d6bb0347e281f3ab2213525ae675c4785af4537215d4bf51f059b82e73eb0387b93c149bf88ec6b1668901637f9f93e178914d8f7d0fc9f148d78a48dc25102990522d468bcb7e0d18d18786ea8d10e96daaeba95d7d3bf85d7e445f5359de314b4f40a95bc2f4622564159f74412be8e8d3a99f3cd39477166931437f5791ec155ca329485f10b22461ba4a6f46c5a7fc479a87a24cc5a4e6534e044aab4b83cac8d15d1ee8f2b79cdff80dbcf01729265565d4d797afeed3d28e930f79598f2eeeb71eaf9bbce33c7b7e1095acc04db17f039376cc007d42f23d5f85dd1942ccf2aca3028450e7137eda9c4df7ff0219181d86f72cf7f775bec57d1df3b4b0d24a5a9b1b9cc8cc52c980a56f7fa949a03d0183e7c48f12d08a69ef854b5a8ec0f10b50d3e399cf028f277df20e1f33e668361f000715befa127c4c4b0b63f8e85b8e117f31c7f1f8fd84896afa2c23461d2b4d9ad3db61cbdaa39503e488ef5d94a0de5380b4b36f13c7f9477eca53f8aec607afacc9cd8d37494e47bfe8001774ccc2bac7ddd19cbd90246f717f5d511c25ded559f4c7fb27a5784a39565efc77843b564c82f9022e055b0406abc221e2cf56ef0c2337f63b5360826e817ead43e82a4873ab18ab997d043f941ae86077d3f052911dd05697d2ea8ce81ca55adbefe727c1fe83da23821b39b3801b314618007811f7fbc8628e28f392858811e6310273fa8958d64c4d564ad0ee5d6a0ad3bf9ede05a5b2109483cc1dd0e85b781f72fb9bc23d1482c75b926d64df29034b8c4b7d233ecdf4cf72d33a61c09e7b887f6982f7778bf10dca4e7352d48f1dc03c223c7b6c3ac4fe2d109c3941196dc033ceb91cb3ea5d909fc196811fc61b199709b4b4c9fb0ee2c9100d4278cf29e57542991e108aef5d6d82c8882f622d05280175437bcfa0bdc148137335f0944aff5e199b6c6f09df0f3f38155d4b8bad337706c9ccfd89dfdc96dc246dd6aac1346629d2051a3f0d03a274a1ef4de1833c287657656ce987d9e570eadfbfb7fe55634cb9780fb5962ad42cedc32ff8139fd8706602f7e5ac021f658b4e2f299db2f006894b91c053f2f47e95d319f55395bd4332ca6bb33170864f6504022705ea6c86c679495853f237e076b24e180f6e5875f6e00455229756d521346fea688d821bf7b8d04c00845366e189374e5e193577b18702f9cc645c0dbfdc9f87cd417126708fa20176ad4a84dea1808871fc7139f25a21fe81ac2206903c339f013924c0d5284875e9d16d50c890ef40fccbe588c04d08e476313baa32b17f0f43e3bfe5e70748dbf1a1e7c119c16830ec2e606bc7a5804c28659a8d84b9bd4202a2366928c23e82c78ddf8e836c385c68f21ccaa14a8febcd5a29e1bd439e699b9fc6f741d1bcf48303cf29272bbffacf87c87e2fe4fe85b886d0873d2499a1642a49b29fe151a0d59d9f9b0a1fab0371bdd5f91a6427add007d02e09301b2029ebf2f24822e96e93aad4b9ecfa669ffdceba557d0a1c13cc3e8a47d2e5ef5b6360e864d940cea37007e80b01888641015c11aaa1432ca32c02c7916f477a822f94ce286492f1fd9d3a1a40b5f0ea5002cf946bb99ae8081d01d143326a6025f14b1a204f93f7c7057ac1d9fa1a672c0e50fc4a206d52e28df1fe9f9780c192c48d62057b1e90970f459d7bb7625b66d978f4fe58e33705be38fdc7010247c4e2d949ba89839f4560b41867d291a7337562bf05cabe86da13cbef259aa5ce033ef4056b25c00aeb80c647f88c1787d90e884596b0d269790e2ec4fd1972b408541d28190be31278721cfc624b7b0346ee5bf2dd9a7c4f48fe02cb519e188cc51fd1098e4ffe4f2f6d3ef2175edc135d57345fe81b35b9a67c0c3e1c22cb6312ea2aea84b353d83ff28cd614044bdb850c2b28a195214ac2fac9cbf9309667c965cf59849b874e1ba526f2cd8f1af9a8d03d88a1aa605d6576e6f57faed6c51b1bad316ede286045f3dde5f2cf7cc819c390d155f18310179d8d6db8cdc480cc5afee3c768956c42daa0fc6c50bc776a49aad0a3470a7fb490fa1c80df2949ac81288ea3a468f7491ee3a149e0c523e022dab2c410087b1ce6a5cf5321156af418421fb4f8139bd8df59072e9ed89b84dba5d4808d19b6","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9fdd6a30e734b0ce7de31a0a221786bf"};

      // you can edit these values to customize some of the behavior of StatiCrypt
      const templateConfig = {
        rememberExpirationKey: "staticrypt_expiration",
        rememberPassphraseKey: "staticrypt_passphrase",
        replaceHtmlCallback: null,
        clearLocalStorageCallback: null,
      };

      // init the staticrypt engine
      const staticrypt = staticryptInitiator.init(
        staticryptConfig,
        templateConfig
      );

      // try to automatically decrypt on load if there is a saved password
      window.onload = async function () {
        const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

        // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
        // replaced, no need to do anything
        if (!isSuccessful) {
          // hide loading screen
          document.getElementById("staticrypt_loading").classList.add("hidden");
          document
            .getElementById("staticrypt_content")
            .classList.remove("hidden");
          document.getElementById("staticrypt-password").focus();

          // show the remember me checkbox
          if (isRememberEnabled) {
            document
              .getElementById("staticrypt-remember-label")
              .classList.remove("hidden");
          }
        }
      };

      // handle password form submission
      document
        .getElementById("staticrypt-form")
        .addEventListener("submit", async function (e) {
          e.preventDefault();

          const passphrase = document.getElementById(
              "staticrypt-password"
            ).value,
            isRememberChecked = document.getElementById(
              "staticrypt-remember"
            ).checked;

          const { isSuccessful } = await staticrypt.handleDecryptionOfPage(
            passphrase,
            isRememberChecked
          );

          if (!isSuccessful) {
            alert(templateError);
          }
        });
    </script>
  </body>
</html>
